/**
 * Settings Route
 * System configuration management
 */

const express = require('express');
const router = express.Router();
const fs = require('fs');
const path = require('path');
const crypto = require('crypto');

const SETTINGS_FILE = path.join(__dirname, '..', '..', '.env');

// Security constants
const MIN_SECRET_LENGTH = 32;
const WEAK_SECRETS = ['your_secret_key_here', 'secret', 'password', '123456'];

/**
 * Generate a cryptographically secure random secret
 */
function generateSecureSecret() {
    return crypto.randomBytes(32).toString('hex');
}

/**
 * Validate session secret for security requirements
 * @param {string} secret - The secret to validate
 * @returns {object} - {valid: boolean, error: string}
 */
function validateSessionSecret(secret) {
    if (!secret || typeof secret !== 'string') {
        return { valid: false, error: 'Session secret is required' };
    }

    // Check for weak/common secrets
    if (WEAK_SECRETS.some(weak => secret.toLowerCase().includes(weak.toLowerCase()))) {
        return { valid: false, error: 'Session secret is too weak. Please use a strong, unique secret.' };
    }

    // Check minimum length
    if (secret.length < MIN_SECRET_LENGTH) {
        return { 
            valid: false, 
            error: `Session secret must be at least ${MIN_SECRET_LENGTH} characters long for security.` 
        };
    }

    return { valid: true };
}

/**
 * Read current settings from .env file
 */
function readEnvSettings() {
    const settings = {};
    
    if (fs.existsSync(SETTINGS_FILE)) {
        const envContent = fs.readFileSync(SETTINGS_FILE, 'utf8');
        envContent.split('\n').forEach(line => {
            const trimmed = line.trim();
            if (trimmed && !trimmed.startsWith('#')) {
                const [key, ...valueParts] = trimmed.split('=');
                const value = valueParts.join('=');
                if (key && value !== undefined) {
                    settings[key.trim()] = value.trim();
                }
            }
        });
    }
    
    return settings;
}

/**
 * Write settings to .env file
 */
function writeEnvSettings(settings) {
    let content = '# AnomHome Overmind Configuration\n';
    content += '# Generated by settings panel\n\n';
    content += '# Server Configuration\n';
    content += `PORT=${process.env.PORT || 3000}\n`;
    content += `HOST=${process.env.HOST || '0.0.0.0'}\n\n`;
    
    content += '# AI Configuration\n';
    if (settings.aiProvider === 'local') {
        content += `AI_PROVIDER=local\n`;
        content += `LOCAL_MODEL_PATH=${settings.localModelPath || ''}\n`;
        content += `MODEL_CONTEXT_SIZE=${settings.modelContextSize || 4096}\n`;
        content += `LOCAL_SERVER_PORT=${settings.localServerPort || 8080}\n`;
    } else {
        content += `AI_PROVIDER=openai\n`;
        content += `OPENAI_API_KEY=${settings.openaiKey || ''}\n`;
    }
    content += '\n';
    
    content += '# File Browser Configuration\n';
    content += `FILE_BROWSER_ROOT=${settings.fileRoot || ''}\n\n`;
    
    content += '# Upload Configuration\n';
    content += `MAX_UPLOAD_SIZE=${settings.maxUploadSize || 100}\n\n`;
    
    content += '# Security\n';
    // Never write a weak default - require a valid secret
    if (settings.sessionSecret && settings.sessionSecret !== 'your_secret_key_here') {
        content += `SECRET_KEY=${settings.sessionSecret}\n`;
    } else {
        // If no valid secret provided, generate a secure one
        const secureSecret = generateSecureSecret();
        content += `SECRET_KEY=${secureSecret}\n`;
        console.warn('[Settings] Generated new secure session secret');
    }
    
    fs.writeFileSync(SETTINGS_FILE, content, 'utf8');
}

/**
 * GET /api/settings
 * Get current settings
 */
router.get('/', (req, res) => {
    try {
        const envSettings = readEnvSettings();
        
        const settings = {
            aiProvider: envSettings.AI_PROVIDER || 'openai',
            openaiKey: envSettings.OPENAI_API_KEY || '',
            localModelPath: envSettings.LOCAL_MODEL_PATH || '',
            modelContextSize: parseInt(envSettings.MODEL_CONTEXT_SIZE) || 4096,
            localServerPort: parseInt(envSettings.LOCAL_SERVER_PORT) || 8080,
            fileRoot: envSettings.FILE_BROWSER_ROOT || '',
            maxUploadSize: parseInt(envSettings.MAX_UPLOAD_SIZE) || 100,
            sessionSecret: envSettings.SECRET_KEY ? '****' : '' // Hide actual secret
        };
        
        res.json(settings);
        
    } catch (err) {
        console.error('[Settings] Get error:', err.message);
        res.status(500).json({ error: 'Failed to load settings' });
    }
});

/**
 * POST /api/settings
 * Update settings
 */
router.post('/', (req, res) => {
    try {
        const {
            aiProvider,
            openaiKey,
            localModelPath,
            modelContextSize,
            localServerPort,
            fileRoot,
            maxUploadSize,
            sessionSecret
        } = req.body;

        // Validate required fields based on AI provider
        if (aiProvider === 'openai' && !openaiKey) {
            return res.status(400).json({ error: 'OpenAI API key is required' });
        }

        if (aiProvider === 'local' && !localModelPath) {
            return res.status(400).json({ error: 'Local model path is required' });
        }

        // Validate numeric configuration values if provided
        let validatedModelContextSize = modelContextSize;
        if (modelContextSize !== undefined && modelContextSize !== null && modelContextSize !== '') {
            const parsedModelContextSize = parseInt(modelContextSize, 10);
            if (!Number.isFinite(parsedModelContextSize) || parsedModelContextSize <= 0 || parsedModelContextSize > 1000000) {
                return res.status(400).json({ error: 'modelContextSize must be a positive integer between 1 and 1000000.' });
            }
            validatedModelContextSize = parsedModelContextSize;
        }

        let validatedLocalServerPort = localServerPort;
        if (localServerPort !== undefined && localServerPort !== null && localServerPort !== '') {
            const parsedLocalServerPort = parseInt(localServerPort, 10);
            if (!Number.isFinite(parsedLocalServerPort) || parsedLocalServerPort <= 0 || parsedLocalServerPort > 65535) {
                return res.status(400).json({ error: 'localServerPort must be a valid TCP port between 1 and 65535.' });
            }
            validatedLocalServerPort = parsedLocalServerPort;
        }

        let validatedMaxUploadSize = maxUploadSize;
        if (maxUploadSize !== undefined && maxUploadSize !== null && maxUploadSize !== '') {
            const parsedMaxUploadSize = parseInt(maxUploadSize, 10);
            if (!Number.isFinite(parsedMaxUploadSize) || parsedMaxUploadSize <= 0 || parsedMaxUploadSize > 1000000000) {
                return res.status(400).json({ error: 'maxUploadSize must be a positive integer between 1 and 1000000000.' });
            }
            validatedMaxUploadSize = parsedMaxUploadSize;
        }

        // Validate or generate session secret
        let validatedSessionSecret = sessionSecret;
        if (sessionSecret && sessionSecret !== '****') {
            // User provided a secret, validate it
            const validation = validateSessionSecret(sessionSecret);
            if (!validation.valid) {
                return res.status(400).json({ error: validation.error });
            }
            validatedSessionSecret = sessionSecret;
        } else {
            // No secret provided or placeholder, read existing or generate new
            const envSettings = readEnvSettings();
            const existingSecret = envSettings.SECRET_KEY;
            
            // Check if existing secret is valid
            if (existingSecret && validateSessionSecret(existingSecret).valid) {
                validatedSessionSecret = existingSecret;
            } else {
                // Generate a new secure secret
                validatedSessionSecret = generateSecureSecret();
                console.warn('[Settings] Generated new secure session secret');
            }
        }

        // Write settings to .env file
        writeEnvSettings({
            aiProvider,
            openaiKey,
            localModelPath,
            modelContextSize: validatedModelContextSize,
            localServerPort: validatedLocalServerPort,
            fileRoot,
            maxUploadSize: validatedMaxUploadSize,
            sessionSecret: validatedSessionSecret
        });

        res.json({
            success: true,
            message: 'Settings saved successfully. Restart the server to apply changes.'
        });
    } catch (err) {
        console.error('[Settings] Update error:', err.message);
        res.status(500).json({ error: 'Failed to save settings' });
    }
});

module.exports = router;