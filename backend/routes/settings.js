/**
 * Settings Route
 * System configuration management
 */

const express = require('express');
const router = express.Router();
const fs = require('fs');
const path = require('path');
const crypto = require('crypto');

const SETTINGS_FILE = path.join(__dirname, '..', '..', '.env');

/**
 * Authentication middleware for settings routes
 * Checks for a simple admin key in environment or session
 * 
 * SECURITY WARNING: This is a basic implementation.
 * For production use, implement proper authentication with:
 * - User sessions (express-session)
 * - Password hashing (bcrypt)
 * - HTTPS/TLS encryption
 */
function requireAuth(req, res, next) {
    // Check if ADMIN_KEY is configured in environment
    const adminKey = process.env.ADMIN_KEY;
    
    // If no admin key is configured, log a warning and allow access
    // This maintains backward compatibility but warns about the security risk
    if (!adminKey) {
        console.warn('[Settings] WARNING: No ADMIN_KEY configured. Settings endpoint is unprotected!');
        console.warn('[Settings] Set ADMIN_KEY in .env file to secure settings access.');
        return next();
    }
    
    // Check for admin key in request header
    const providedKey = req.headers['x-admin-key'];
    
    if (providedKey !== adminKey) {
        return res.status(401).json({ 
            error: 'Authentication required. Provide X-Admin-Key header with valid admin key.',
            hint: 'Configure ADMIN_KEY in .env file for settings access control.'
        });
    }
    
    next();
}

/**
 * Generate a secure random secret
 */
function generateSecureSecret() {
    return crypto.randomBytes(32).toString('hex');
}

/**
 * Validate session secret meets minimum security requirements
 */
function validateSessionSecret(secret) {
    if (!secret || secret === 'your_secret_key_here') {
        return false;
    }
    // Minimum 16 characters for security
    if (secret.length < 16) {
        return false;
    }
    return true;
}

/**
 * Validate file path to prevent directory traversal attacks
 */
function validateFilePath(filePath) {
    if (!filePath) return true; // Empty is allowed
    
    // Resolve to absolute path to normalize separators
    const resolvedPath = path.resolve(filePath);
    
    // Check for directory traversal attempts
    // Ensure the resolved path doesn't try to escape outside reasonable boundaries
    if (resolvedPath.includes('..')) {
        return false;
    }
    
    // Check if path exists and is a directory
    try {
        if (fs.existsSync(resolvedPath)) {
            const stat = fs.statSync(resolvedPath);
            if (!stat.isDirectory()) {
                return false;
            }
        }
    } catch (err) {
        return false;
    }
    
    return true;
}

/**
 * Read current settings from .env file
 */
function readEnvSettings() {
    const settings = {};
    
    if (fs.existsSync(SETTINGS_FILE)) {
        const envContent = fs.readFileSync(SETTINGS_FILE, 'utf8');
        envContent.split('\n').forEach(line => {
            const trimmed = line.trim();
            if (trimmed && !trimmed.startsWith('#')) {
                const [key, ...valueParts] = trimmed.split('=');
                const value = valueParts.join('=');
                if (key && value !== undefined) {
                    settings[key.trim()] = value.trim();
                }
            }
        });
    }
    
    return settings;
}

/**
 * Write settings to .env file
 */
function writeEnvSettings(settings) {
    let content = '# AnomHome Overmind Configuration\n';
    content += '# Generated by settings panel\n\n';
    content += '# Server Configuration\n';
    content += `PORT=${process.env.PORT || 3000}\n`;
    content += `HOST=${process.env.HOST || '0.0.0.0'}\n\n`;
    
    content += '# AI Configuration\n';
    if (settings.aiProvider === 'local') {
        content += `AI_PROVIDER=local\n`;
        content += `LOCAL_MODEL_PATH=${settings.localModelPath || ''}\n`;
        content += `MODEL_CONTEXT_SIZE=${settings.modelContextSize || 4096}\n`;
        content += `LOCAL_SERVER_PORT=${settings.localServerPort || 8080}\n`;
    } else {
        content += `AI_PROVIDER=openai\n`;
        content += `OPENAI_API_KEY=${settings.openaiKey || ''}\n`;
    }
    content += '\n';
    
    content += '# File Browser Configuration\n';
    content += `FILE_BROWSER_ROOT=${settings.fileRoot || ''}\n\n`;
    
    content += '# Upload Configuration\n';
    content += `MAX_UPLOAD_SIZE=${settings.maxUploadSize || 100}\n\n`;
    
    content += '# Security\n';
    content += `SECRET_KEY=${settings.sessionSecret || 'your_secret_key_here'}\n`;
    
    fs.writeFileSync(SETTINGS_FILE, content, 'utf8');
}

/**
 * GET /api/settings
 * Get current settings
 */
router.get('/', requireAuth, (req, res) => {
    try {
        const envSettings = readEnvSettings();
        
        const settings = {
            aiProvider: envSettings.AI_PROVIDER || 'openai',
            // Never send the actual API key to the client
            openaiKey: envSettings.OPENAI_API_KEY ? '****' : '',
            localModelPath: envSettings.LOCAL_MODEL_PATH || '',
            modelContextSize: parseInt(envSettings.MODEL_CONTEXT_SIZE) || 4096,
            localServerPort: parseInt(envSettings.LOCAL_SERVER_PORT) || 8080,
            fileRoot: envSettings.FILE_BROWSER_ROOT || '',
            maxUploadSize: parseInt(envSettings.MAX_UPLOAD_SIZE) || 100,
            sessionSecret: envSettings.SECRET_KEY ? '****' : '' // Hide actual secret
        };
        
        res.json(settings);
        
    } catch (err) {
        console.error('[Settings] Get error:', err.message);
        res.status(500).json({ error: 'Failed to load settings' });
    }
});

/**
 * POST /api/settings
 * Update settings
 */
router.post('/', requireAuth, (req, res) => {
    try {
        const {
            aiProvider,
            openaiKey,
            localModelPath,
            modelContextSize,
            localServerPort,
            fileRoot,
            maxUploadSize,
            sessionSecret
        } = req.body;
        
        // Validate required fields based on AI provider
        if (aiProvider === 'openai' && !openaiKey) {
            return res.status(400).json({ error: 'OpenAI API key is required' });
        }
        
        if (aiProvider === 'local' && !localModelPath) {
            return res.status(400).json({ error: 'Local model path is required' });
        }
        
        // Validate session secret
        if (sessionSecret && sessionSecret !== '****' && !validateSessionSecret(sessionSecret)) {
            return res.status(400).json({ 
                error: 'Session secret must be at least 16 characters long and cannot be the default value.' 
            });
        }
        
        // Validate file root path for security
        if (fileRoot && !validateFilePath(fileRoot)) {
            return res.status(400).json({ 
                error: 'Invalid file root path. Path cannot contain ".." or must be a valid directory.' 
            });
        }
        
        // Validate numeric configuration values
        let validatedModelContextSize = modelContextSize;
        if (modelContextSize !== undefined && modelContextSize !== null && modelContextSize !== '') {
            const parsedModelContextSize = parseInt(modelContextSize, 10);
            if (!Number.isFinite(parsedModelContextSize) || parsedModelContextSize <= 0 || parsedModelContextSize > 1000000) {
                return res.status(400).json({ 
                    error: 'Model context size must be a positive integer between 1 and 1,000,000.' 
                });
            }
            validatedModelContextSize = parsedModelContextSize;
        }
        
        let validatedLocalServerPort = localServerPort;
        if (localServerPort !== undefined && localServerPort !== null && localServerPort !== '') {
            const parsedLocalServerPort = parseInt(localServerPort, 10);
            // Restrict to non-privileged ports
            if (!Number.isFinite(parsedLocalServerPort) || parsedLocalServerPort < 1024 || parsedLocalServerPort > 65535) {
                return res.status(400).json({ 
                    error: 'Server port must be between 1024 and 65535.' 
                });
            }
            validatedLocalServerPort = parsedLocalServerPort;
        }
        
        let validatedMaxUploadSize = maxUploadSize;
        if (maxUploadSize !== undefined && maxUploadSize !== null && maxUploadSize !== '') {
            const parsedMaxUploadSize = parseInt(maxUploadSize, 10);
            // Limit to reasonable upload sizes (1MB to 1GB)
            if (!Number.isFinite(parsedMaxUploadSize) || parsedMaxUploadSize <= 0 || parsedMaxUploadSize > 1000) {
                return res.status(400).json({ 
                    error: 'Max upload size must be between 1 and 1000 MB.' 
                });
            }
            validatedMaxUploadSize = parsedMaxUploadSize;
        }
        
        // Read current settings to preserve API key if masked
        const currentSettings = readEnvSettings();
        const finalOpenaiKey = (openaiKey && openaiKey !== '****') ? openaiKey : currentSettings.OPENAI_API_KEY;
        const finalSessionSecret = (sessionSecret && sessionSecret !== '****') ? sessionSecret : currentSettings.SECRET_KEY;
        
        // Generate secure secret if none provided or invalid
        let finalSecret = finalSessionSecret;
        if (!finalSecret || !validateSessionSecret(finalSecret)) {
            finalSecret = generateSecureSecret();
            console.log('[Settings] Generated new secure session secret');
        }
        
        // Write settings to .env file
        writeEnvSettings({
            aiProvider,
            openaiKey: finalOpenaiKey,
            localModelPath,
            modelContextSize: validatedModelContextSize,
            localServerPort: validatedLocalServerPort,
            fileRoot,
            maxUploadSize: validatedMaxUploadSize,
            sessionSecret: finalSecret
        });
        
        res.json({
            success: true,
            message: 'Settings saved successfully. Restart the server to apply changes.'
        });
        
    } catch (err) {
        console.error('[Settings] Update error:', err.message);
        res.status(500).json({ error: 'Failed to save settings' });
    }
});

module.exports = router;